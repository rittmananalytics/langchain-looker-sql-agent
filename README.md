# LangChain Looker SQL Agent

A [LangChain SQL agent](https://blog.langchain.dev/how-to-safely-query-enterprise-data-with-langchain-agents-sql-openai-gretel) designed to connect to Looker instances via Looker's [Open SQL Interface](https://cloud.google.com/looker/docs/sql-interface). It utilizes the official Avatica-based JDBC driver and enables users to interact with their Looker data conversationally. Natural language questions are translated into Looker-specific SQL queries, executed, and the results are used to answer the user.

**Core Functionality:**
*   Connects to Looker using the official [Avatica JDBC driver](https://github.com/looker-open-source/calcite-avatica/releases).
*   Utilizes a custom `LookerSQLDatabase` wrapper compatible with [LangChain's SQL tool](https://python.langchain.com/docs/integrations/tools/sql_database/) interaction patterns.
*   Provides a `LookerSQLToolkit` that bundles database interaction tools using LangChain's `Tool.from_function`.
*   Implements a `create_looker_sql_agent` factory function to build a ReAct-based LangChain agent.
*   The agent can:
    *   List available Looker Explores (treated as queryable tables).
    *   Retrieve the schema of Explores, understanding the `LookML Model Name` as the schema and `Explore Name` as the table. Column names are presented in `view_name.field_name` format.
    *   Read Looker-specific field metadata (FIELD_LABEL, FIELD_ALIAS, and FIELD_DESCRIPTION) when retrieving Looker column names.
    *   Fetch sample rows from Explores (configurable, uses specific columns to avoid `SELECT *` issues).
    *   Execute SQL queries generated by an LLM against Looker Explores, [correctly handling](https://cloud.google.com/looker/docs/sql-interface#sql_limitations):
        *   Backticked identifiers: `` `model_name`.`explore_name` ``, `` `view_name.field_name` ``.
        *   The `AGGREGATE(\`view_name.measure_name\`)` function for LookML measures.
        *   Standard SQL aggregate functions like `COUNT(*)` on Explores.
        *   Exclusion of trailing semicolons.
    *   Self-correct queries based on errors and schema information.
    *   More details on the technical implementation in the [TECHNICAL_README](https://github.com/rittmananalytics/langchain-looker-sql-agent/blob/main/TECHNICAL_README.md).

## Features
*   **Conversational Data Querying:** Ask complex questions in natural language to query your Looker data.
*   **Looker Open SQL Interface (Avatica/Calcite) Integration:** Uses the official JDBC driver for robust connectivity and [adheres to its SQL dialect](https://cloud.google.com/looker/docs/sql-interface#running-queries-with-the-sql-interface).
*   **LookML Aware:** The agent is prompted to understand and correctly query Looker's structure (Models, Explores, Views, Fields, Measures including Looker-specific column metadata).
*   **LangChain Compatible:** Built with standard LangChain components.
*   **Memory Enabled:** The example conversational agent demonstrates support for `ConversationBufferMemory` via the `AgentExecutor`.

## Prerequisites

## Prerequisites

Before you begin, ensure you have the following:

1.  **Python:** Version 3.8 or newer.
2.  **Java Runtime Environment (JRE) or Development Kit (JDK):**
    *   **Version 11 or newer is recommended.** This is required by the `JayDeBeApi` library to interact with the JDBC driver.
    *   **Installation:**
        *   **For Debian/Ubuntu-based systems (like many cloud VMs, including Vertex AI Notebooks):**
            ```bash
            sudo apt-get update
            sudo apt-get install -y openjdk-11-jdk --no-install-recommends
            java -version # Verify installation
            ```
        *   **For macOS (using Homebrew):**
            ```bash
            brew install openjdk@11
            # You might need to symlink it or set JAVA_HOME, e.g.:
            # sudo ln -sfn /usr/local/opt/openjdk@11/libexec/openjdk.jdk /Library/Java/JavaVirtualMachines/openjdk-11.jdk
            # echo 'export JAVA_HOME="/usr/local/opt/openjdk@11/libexec/openjdk.jdk/Contents/Home"' >> ~/.zshrc # or ~/.bash_profile
            # source ~/.zshrc
            java -version
            ```
        *   **For Windows:** Download an OpenJDK 11 (or newer) installer (e.g., from Adoptium/Eclipse Temurin, Azul Zulu, Amazon Corretto) and follow its installation instructions.
    *   **`JAVA_HOME` Environment Variable:** Ensure the `JAVA_HOME` environment variable is set correctly to point to the root directory of your JDK/JRE installation.
        *   The example notebooks include Python code to attempt to verify/set this for common Linux paths, but you might need to set it manually in your system environment or shell profile (`.bashrc`, `.zshrc`, `.bash_profile`, or System Environment Variables on Windows).
        *   Example Linux: `export JAVA_HOME=/usr/lib/jvm/java-11-openjdk-amd64`
        *   Example macOS (after Homebrew): `export JAVA_HOME=$(/usr/libexec/java_home -v 11)` or the path shown by `brew info openjdk@11`.
3.  **Looker Instance:**
    *   Access to a Looker instance with the SQL Interface (JDBC) enabled.
    *   Your Looker Instance URL (e.g., `https://yourcompany.cloud.looker.com`).
4.  **Looker API3 Credentials:**
    *   A Client ID and Client Secret for a Looker user with API3 access.
    *   This user must have permissions to query the desired LookML model(s)/connection(s) via the SQL Interface.
5.  **LookML Model Name:** The name of the LookML model the agent will query (e.g., `analytics`).
6.  **Looker Avatica JDBC Driver:**
    *   The `avatica-<version>-looker.jar` file.
    *   Download from: [looker-open-source/calcite-avatica/releases](https://github.com/looker-open-source/calcite-avatica/releases).
7.  **LLM API Key:** (e.g., for OpenAI, Anthropic). The examples use OpenAI (`gpt-4o` recommended for best results).

## Setup Instructions

Note that tool was developed and tested using JupyterLab 3 running as a managed instance on Vertex AI Workbench, and has not been tested running directly on a Mac, Windows etc.

1.  **Clone the Repository...**
2.  **Create and Activate a Virtual Environment...**
3.  **Verify/Install Java and Set `JAVA_HOME`:**
    *   Ensure you have a compatible JDK/JRE (see Prerequisites).
    *   Verify `JAVA_HOME` is correctly set in your terminal session *before proceeding*. The agent will not work without it.
4.  **Install Python Dependencies:**
    ```bash
    pip install -r requirements.txt
5.  **Download + Place the Looker JDBC Driver:**
    ```bash
    mkdir drivers
    cd drivers
    wget https://github.com/looker-open-source/calcite-avatica/releases/download/avatica-1.26.0-looker/avatica-1.26.0-looker.jar
    ```

6.  **Configure Environment Variables:**
    ```bash
    cd ..
    cp .env.example .env
    vi .env
    OPENAI_API_KEY="sk-YOUR_OPENAI_API_KEY_HERE"
    LOOKER_INSTANCE_URL="https://yourcompany.cloud.looker.com"
    LOOKML_MODEL_NAME="your_lookml_model_name" # e.g., analytics
    LOOKER_CLIENT_ID="YOUR_LOOKER_API3_CLIENT_ID"
    LOOKER_CLIENT_SECRET="YOUR_LOOKER_API3_CLIENT_SECRET"
    LOOKER_JDBC_DRIVER_PATH="./drivers/avatica-1.24.0-looker.jar" # ADJUST VERSION
    JAVA_HOME=""
    ```

## How to Run Tests and Demonstrate Functionality

The primary way to test and demonstrate this agent is via the Jupyter Notebook:

*   **`notebooks/looker_langchain_sql_agent_tests.ipynb`**

1.  Ensure all setup steps above are complete.
2.  Activate your Python virtual environment.
3.  Start JupyterLab or Jupyter Notebook from the project's root directory:
    ```bash
    jupyter lab  # or jupyter notebook
    ```
4.  Navigate to and open `notebooks/looker_langchain_sql_agent_tests.ipynb`.
5.  **Run the cells sequentially.** The notebook is structured to:
    *   Perform initial environment checks and load configurations.
    *   Initialize the `LookerSQLDatabase` component.
    *   Run manual tests directly against `LookerSQLDatabase` to verify basic connectivity and metadata retrieval (including sample rows).
    *   Initialize the LLM, memory, and the `LookerSQLToolkit`.
    *   Create the `AgentExecutor`.
    *   Execute a series of pre-determined basic and advanced agent tests, including questions that require the agent to:
        *   List available Explores.
        *   Describe an Explore's schema.
        *   Perform simple `COUNT(*)` aggregations.
        *   Correctly use the [`AGGREGATE(\`view.measure\`)`](https://cloud.google.com/looker/docs/sql-interface#specify_lookml_measures_with_aggregate) function for LookML measures.
        *   Group by dimensions while aggregating measures.
        *   Apply filters in conjunction with aggregations.
        *   Adhere to SQL syntax rules like using backticks and avoiding semicolons.
    *   The notebook also includes a section for an interactive chat loop (currently commented out in the "Advanced Tests" version but can be re-enabled or run after the pre-determined tests).

**Expected Output:**
The notebook will log detailed information about each step. Successful tests will show the agent's thought process (if `verbose=True`), the SQL queries it generates, the results from Looker, and the final answer.

## Key Technical Details & Looker SQL Syntax

The agent and its underlying database wrapper (`LookerSQLDatabase`) are designed to work with the specific SQL dialect and requirements of Looker's Open SQL Interface (Avatica/Calcite):

*   **JDBC Driver:** `org.apache.calcite.avatica.remote.looker.LookerDriver`
*   **JDBC URL:** `jdbc:looker:url=https://your_looker_instance_url`
*   **Schema/Table/Column Identifiers:**
    *   **LookML Model Name as Schema:** Used as the `schemaPattern` for JDBC metadata calls.
    *   **Explore Name as Table:** Queried as `` `model_name`.`explore_name` ``.
    *   **View & Field Name as Column:** Queried as `` `view_name.field_name` `` with SQL-style comments (--) containing the FIELD_LABEL (if different from the view.field name), FIELD_ALIAS, FIELD_CATEGORY, and a truncated FIELD_DESCRIPTION.
    *   **Backticks (` `) are mandatory** for all these identifiers in SQL queries.
*   **LookML Measures:** Must be queried using the `AGGREGATE(\`view_name.measure_name\`)` function. Measures cannot be used in `GROUP BY` clauses. Standard SQL aggregates (e.g., `COUNT(*)`, `SUM(\`dimension\`)`) can be used on dimensions.
*   **SQL Limitations:**
    *   `SELECT` statements only.
    *   No explicit `JOIN` operators (joins are defined in LookML Explores).
    *   No SQL window functions.
    *   No subqueries.
    *   No trailing semicolons (`;`) in queries.
*   **Agent Prompting:** The `LOOKER_SQL_SYSTEM_INSTRUCTIONS_TEMPLATE` within `langchain_looker_sql_agent.py` is heavily customized to guide the LLM on these specific syntax rules and limitations.

## Design Choices & Technical Notes

### Why a Custom `LookerSQLDatabase` Wrapper and Not a New SQLAlchemy Dialect?

A key design decision for this prototype was to implement a custom `LookerSQLDatabase` class that mimics the interface of LangChain's `SQLDatabase` utility, rather than attempting to create a new SQLAlchemy dialect for Looker's Open SQL Interface. The primary reasons for this approach are:

1.  **Nature of Looker's SQL Interface:**
    *   Looker's Open SQL Interface is an abstraction layer over underlying databases, accessed via a specific JDBC driver (the Avatica-based one documented by Looker).
    *   It does not expose itself as a standard relational database that typical Python DB-API v2.0 compliant drivers (which SQLAlchemy relies on) can connect to directly.
    *   We use `JayDeBeApi` to bridge Python to Java's JDBC, as there isn't a native Python DB-API driver for this Looker interface.

2.  **Complexity of Full SQLAlchemy Dialect Implementation:**
    *   Creating a complete SQLAlchemy dialect is a significant undertaking. It requires handling intricate details such as connection string parsing, comprehensive type mapping, SQL compilation for a wide range of DDL/DML operations (many of which may not be relevant or fully supported by Looker's read-focused SQL Interface), full introspection capabilities as expected by SQLAlchemy, and transaction management.
    *   Given Looker's abstracted SQL layer and its specific syntax requirements (e.g., backticked identifiers like `` `model_name`.`explore_name` ``), adapting this to the full SQLAlchemy dialect model would be overly complex for the agent's primary needs.

3.  **LangChain's `SQLDatabase` Utility as a Simpler Abstraction:**
    *   The `langchain_community.utilities.SQLDatabase` class provides a lightweight and targeted interface specifically for what LangChain SQL agents typically require:
        *   A `dialect` property.
        *   A method to `get_usable_table_names()` (Explores, in our case).
        *   A method to `get_table_info(table_names)` (schema for Explores).
        *   A method to `run(command)` SQL queries.
    *   Our custom `LookerSQLDatabase` implements this simpler interface, fulfilling the agent's needs without the overhead of the entire SQLAlchemy ORM and toolkit.

4.  **Focus on Agent Functionality and Reusability:**
    *   The goal was to achieve functional equivalence with existing LangChain SQL agents (like the BigQuery agent).
    *   By providing a class (`LookerSQLDatabase`) that "looks like" an `SQLDatabase` to LangChain, we can readily use standard LangChain SQL tools (or `Tool.from_function` wrappers around our database methods) and agent constructors (`create_react_agent`). This approach maximizes reuse of existing LangChain agent infrastructure.

5.  **Minimal Dependencies:**
    *   This approach avoids making SQLAlchemy a mandatory dependency, requiring only `JayDeBeApi` and `JPype1` for the core JDBC interaction.

## Troubleshooting

*   **`ModuleNotFoundError` for `langchain_looker_sql_agent`:** Ensure the file is named `langchain_looker_sql_agent.py` (with underscores) and is in the project root. The notebook uses `sys.path` manipulation to find it from the `notebooks/` subdirectory.
*   **`ModuleNotFoundError` for LangChain components:** Run `pip install -r requirements.txt`.
*   **`TypeError: Class org.apache.calcite.avatica.remote.looker.LookerDriver is not found`:** Check `LOOKER_JDBC_DRIVER_PATH` in `.env`; ensure the JAR file exists and is not corrupted.
*   **`ConnectionError` / `JayDeBeApi conn error`:** Verify `LOOKER_INSTANCE_URL`, API3 credentials, network access to Looker, `JAVA_HOME`, and user permissions in Looker.
*   **SQL Errors (e.g., "Object not found", "Non-query expression...") during Agent Execution:**
    *   Examine the `verbose=True` agent output to see the exact SQL generated.
    *   This usually indicates the LLM made a mistake with backticks, `model_name.explore_name` format, or `AGGREGATE()` usage.
    *   The prompt aims to minimize these, but further refinement or more powerful LLMs (like GPT-4o) can improve consistency.
    *   Check if the Explore being queried has `always_filter` or `conditionally_filter` in LookML that might not be satisfied by the agent's query.
*   **SLF4J Warnings:** Generally harmless Java logging messages.

## License
This project is licensed under the Apache 2.0 license.
